https://www.geeksforgeeks.org/dsa/introduction-to-segment-trees-2/


 Initial Array
arr[] = {1, 3, 5, 7, 9, 11}


ðŸŒ³ Segment Tree Construction (constructST)
We build the tree recursively. Each node stores the sum of a segment of the array.
| Node Index | Segment (ssâ€“se) | Value (Sum) | Explanation | 
| 0 | 0â€“5 | 36 | Sum of all elements | 
| 1 | 0â€“2 | 9 | 1 + 3 + 5 | 
| 2 | 3â€“5 | 27 | 7 + 9 + 11 | 
| 3 | 0â€“1 | 4 | 1 + 3 | 
| 4 | 2â€“2 | 5 | Leaf node | 
| 5 | 3â€“4 | 16 | 7 + 9 | 
| 6 | 5â€“5 | 11 | Leaf node | 
| 7 | 0â€“0 | 1 | Leaf node | 
| 8 | 1â€“1 | 3 | Leaf node | 
| 9â€“14 | â€” | â€” | Not used yet | 



ðŸ”§ Update Operation (updateRange(n, 1, 5, 10))
We add 10 to all elements from index 1 to 5. This affects nodes that fully or partially overlap with this range.
Step-by-Step Updates
| Node | Segment | Action | New Value | Lazy Updates | 
| 0 | 0â€“5 | Partial overlap â†’ recurse | â€” | â€” | 
| 1 | 0â€“2 | Partial overlap â†’ recurse | â€” | â€” | 
| 3 | 0â€“1 | Partial overlap â†’ recurse | â€” | â€” | 
| 7 | 0â€“0 | No overlap â†’ return | 1 | â€” | 
| 8 | 1â€“1 | Full overlap â†’ update | 3 + 10 = 13 | â€” | 
| 4 | 2â€“2 | Full overlap â†’ update | 5 + 10 = 15 | â€” | 
| 2 | 3â€“5 | Full overlap â†’ update | 27 + 30 = 57 | lazy[5] = 10, lazy[6] = 10 | 


Recalculate Parent Nodes
| Node | New Value | 
| 3 | 1 + 13 = 14 | 
| 1 | 14 + 15 = 29 | 
| 0 | 29 + 57 = 86 | 


ðŸŒ³ Updated Segment Tree Table
| Node Index | Segment (ssâ€“se) | Value | Lazy | 
| 0 | 0â€“5 | 86 | 0 | 
| 1 | 0â€“2 | 29 | 0 | 
| 2 | 3â€“5 | 57 | 0 | 
| 3 | 0â€“1 | 14 | 0 | 
| 4 | 2â€“2 | 15 | 0 | 
| 5 | 3â€“4 | 16 | 10 | 
| 6 | 5â€“5 | 11 | 10 | 
| 7 | 0â€“0 | 1 | 0 | 
| 8 | 1â€“1 | 13 | 0 | 




