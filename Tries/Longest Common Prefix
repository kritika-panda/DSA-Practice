https://leetcode.com/problems/longest-common-prefix/?envType=problem-list-v2&envId=trie

class Trie {
    boolean isEndOfWord = false;
    Trie[] children = new Trie[26];
}

class Solution {
    Trie head = new Trie();

    public String longestCommonPrefix(String[] strs) {
        if (strs == null || strs.length == 0) return "";

        // Build the Trie
        for (String word : strs) {
            insertIntoTrie(word);
        }

        // Find LCP
        return findLCP(strs[0]); // Use first word as traversal guide
    }

    private void insertIntoTrie(String word) {
        Trie node = head;
        for (char ch : word.toCharArray()) {
            int idx = ch - 'a';
            if (node.children[idx] == null)
                node.children[idx] = new Trie();
            node = node.children[idx];
        }
        node.isEndOfWord = true;
    }

    private String findLCP(String reference) {
        StringBuilder lcp = new StringBuilder();
        Trie node = head;

        for (char ch : reference.toCharArray()) {
            int idx = ch - 'a';
            if (node.children[idx] == null || node.isEndOfWord || countChildren(node) != 1)
                break;
            lcp.append(ch);
            node = node.children[idx];
        }

        return lcp.toString();
    }

    private int countChildren(Trie node) {
        int count = 0;
        for (Trie child : node.children) {
            if (child != null) count++;
        }
        return count;
    }
}


‚úÖ Building the Trie
‚Ä¢ 	Time complexity: O(n * m)
‚Ä¢ 	Each character of each string is inserted once. So for n strings of length up to m, we insert up to n*m
characters.
üîç Finding the Longest Common Prefix
‚Ä¢ 	Time complexity: O(m)
‚Ä¢ 	You start at the root and traverse down as long as:
‚Ä¢ 	The current node has exactly one child
‚Ä¢ 	The current node is not marked as end of word

O(n*m) - Time and space complexity
